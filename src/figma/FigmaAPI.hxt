/**
* 	This file is auto-generated by FigmaAPIExtract.hx
* 	Do not change
**/
package figma;

import haxe.extern.EitherType;
import haxe.Http;
import haxe.Json;
import haxe.macro.Context;
import haxe.macro.Expr.ExprOf;
import haxe.macro.Expr;
import neko.vm.Thread;
import Reflect;
import String;

class FigmaAPI {

	private static inline var API:String = "https://api.figma.com/v1";

	private static inline var MIME_JSON:String = "application/json";
	private static inline var HEADER_CONTENT_TYPE:String = "Content-Type";
	private static inline var HEADER_TOKEN:String = "X-Figma-Token";

	private var token:String;

	public function new(token:String):Void {
		this.token = token;
	}

	public function files(key:String, params:FilesParams, onComplete:Response<Document> -> Void):Void call(methodName(), key, params, onComplete);
	public function images(key:String, params:ImagesParams, onComplete:Response<ImagesResponse> -> Void):Void call(methodName(), key, params, onComplete);

	private function call<P, T, R:Response<T>>(method:String, key:String, params:P = null, onComplete:R -> Void = null):Void {
		var thread:Thread = Thread.create(callAsync);
		var message:Call<P, R> = { method:method, key:key, params:params, onComplete:onComplete };
		thread.sendMessage(message);
	}

	private function callAsync<P, T, R:Response<T>>():Void {
		var message:Call<P, Response<T>> = Thread.readMessage(true);
		var http:Http = new Http('${API}/${message.method}/${message.key}');
		if (message.params != null) for (param in Reflect.fields(message.params)) http.addParameter(
			param, Std.string(Reflect.field(message.params, param))
		);
		http.addHeader(HEADER_CONTENT_TYPE, MIME_JSON);
		http.addHeader(HEADER_TOKEN, token);
		if (message.onComplete != null) http.onData = http.onError = function(_):Void {
			var response:EitherType<T, ResponseError> = Json.parse(http.responseData);
			message.onComplete(Reflect.field(response, 'err') != null ? { error:response } : { data:response });
		}
		http.request();
	}

	#if idea var $v:Expr; #end

	macro public static function methodName():ExprOf<String> {
		return macro $v{Context.getLocalMethod()};
	}
}

typedef Call<P, R> = {

	var method:String;
	var key:String;
	var params:P;
	var onComplete:R -> Void;

}

typedef ResponseError = {

	var err:String;
	var status:Int;

}

typedef Response<T> = {

	@:optional var data:T;
	@:optional var error:ResponseError;

}

typedef FilesParams = {

	@:optional var version:String;
	@:optional var geometry:FilesGeometry;

}

@:enum abstract FilesGeometry(String) {

	var NONE = "";
	var PATHS = "paths";

}

typedef ImagesParams = {

	var ids:String;
	var scale:Float;
	var format:ImageFormat;
	@:optional var version:String;

}

@:enum abstract ImageFormat(String) {

	var JPG = "jpg";
	var PNG = "png";
	var SVG = "svg";

}

typedef ImagesResponse = { > ResponseError,

	var images:EitherType<Map<String, String>, Dynamic>;

}

typedef Document = {

	var schemaVersion:Int;
	var name:String;
	var components:EitherType<Map<String, Component>, Dynamic>;
	var lastModified:String;
	var document:DocumentNode;
	var thumbnailUrl:String;

}

/**
*
*	Nodes
*
**/

typedef Node = {

	var id:String;
	var name:String;
	var visible:Bool;
	var type:NodeType;

}

@:enum abstract NodeType(String) {

	::foreach nodes::var ::id:: = "::type::";
	::end::
}::foreach nodes::

typedef ::name:: = { > ::extend::,

	::foreach vars::::if optional::@:optional ::end::var ::name:::::type::;
	::end::
}::end::

/**
*
*	Types
*
**/::foreach types::

::if (!isEmpty)::typedef ::name:: = {

	::foreach vars::::if optional::@:optional ::end::var ::name:::::type::;
	::end::
}::end::::end::

typedef Transform = Array<Array<Float>>;

typedef Path = {
	var path:String;
	var windingRule:PathWindingRule;
}

/**
*
*	Enums
*
**/::foreach enums::

@:enum abstract ::name::(String) {

	::foreach vars::var ::name:: = ::value::;
	::end::
}::end::

@:enum abstract StyleType(String) {

	var Grid = "GRID";
	var Fill = "FILL";
	var Effect = "EFFECT";

}

@:enum abstract PathWindingRule(String) {

	var Evenodd = "EVENODD";
	var Nonzero = "NONZERO";

}